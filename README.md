# AdapterHelper

Replacement of old, verbose and useless `Adapter` project.

Helps with Adapter pattern implementation and provides deep adapting functionality.

## Use cases

Adapter pattern is used to adapt a type to another without losing capabilities and remaining linked to instance.

For example, if you have 2 platforms, and each platform defines an type called `Person` and you want to treat these types with same code:

```java
public class Lib1_Person {
    private final String name;
    private final int age;
    
    // ...
}

public class Lib2_Person {
    private final String name;
    private final int age;
    private final List<Lib2_Person> parents;
    // ...
}

public class PersonProcessor {
    
    public void process(Lib1_Person person) {
        // ...
    }
    
    public void process(Lib2_Person person) {
        // ...
    }
    
}
```

There are various ways to solve this problem:
 
- Destruct these instances and delegate call to another method. (good, as far you don't need to manipulate other properties and does not call it from many places)
- Process every type in a method. (Bad, too bad)
- Create a proxy and call methods of other type. (Works, is really good and time saver, but at the same time, is hard to maintain if the types have different signatures) **Internally cached**
- Creates an Adapter and cache or instantiate on every call. (Good, and the best way)

Example: See [ReadmeExamples.java](https://github.com/JonathanxD/AdapterHelper/tree/master/src/test/java/com/github/jonathanxd/adapterhelper/test/ReadmeExamples.java).

AdapterHelper provide utilities to working with the last approach and reducing the boilerplate code.

## Adapter Management

Adapter management is made via `AdapterManager`, this class is used to register, get and use adapters and converters. This class also provides a weak cache for Adapter instances.

## Adapter

`Adapter` interface provides a way to retrieve `AdapterManager` and `adaptee instance` which may be used to achieve the adaptation.

## AdapterBase

More simpler interface (which `Adapter` extends) which only provides `original instance`, may be used to achieve some simpler adaptations which does not require an `AdapterManager`.

## Converter

Used to convert values like `String` to `Integer` and vice-versa (unlike `Adapter`, there is no way to fetch `adapter manager`).

## AdapterSpecification

Class used to store specification of `Adapter`, this class is used for registration and internally used to fetch `Adapter`s.

## AdapterImplGen (Requires CodeAPI, CodeAPI-BytecodeWriter and CodeGenUtil)

Utility class used to generate implementation of `Adapter` interfaces (explained later).

## `@Field` & `@Fields`

Used to generate additional fields in implementations generated by `AdapterImplGen`

## Storage and WeakAdapteeStorage

Used to store dynamical fields (alternative for `@Field`)

## StrongCache

Used to Strong cache adapter instances.

## Simple adapter using `AdapterHelper`

There are multiple ways to create adapters using `AdapterHelper` utilities, the mostly used (at least by me), is the combination of `interface adapter` and `AdapterImplGen` because I don't need to create an implementation class and can extend this interface later, example:

[Readme.java](https://github.com/JonathanxD/AdapterHelper/tree/master/src/test/java/com/github/jonathanxd/adapterhelper/test/Readme.java).

## Converters

Converters are used to convert data types, for example, `Integer` to `String` (and vice-versa), or a defined data type to another. 

Converted objects are not cached like `Adapters` and does not have access to `AdapterManager`. Converters are commonly singleton. 

Example:

[Readme.java](https://github.com/JonathanxD/AdapterHelper/tree/master/src/test/java/com/github/jonathanxd/adapterhelper/test/Readme.java).

## Adapters with additional fields.

Sometimes you need to store additional data, but the field does not exists in target class, to solve this problem you can use `@Field` annotation to include fields in your adapter generated class (using `AdapterImplGen`) or add fields to your concrete adapter implementation (make sure to annotate your adapter with `StrongCache`, I will explain it later). You can also use `WeakAdapteeStorage` (or your own implementation of `IStorage`) to store dynamic fields in a map.

`StrongCache` is required because by default, `AdapterManager` caches adapters weakly, this means that if it is not referenced in the code, it will be collected, this causes field values to be lost, to avoid this behavior, you should annotated your adapter class (or any interface or sub-class), but this should be used with care, because it will prevent GC to collect references, which may cause a catastrophe if not manually collected, to collect you should use `uncacheStrong` (or `uncacheAllStrong` if you prefer a generic removal).

**Obs: As the `Field` and `Fields` are annotated with `StrongCache`, all classes annotated with these fields will result in strong caching behavior**

AdapterHelper provides by default a `WeakAdapteeStorage` because we believe that you don't want neither to keep adaptee instance referenced and field values alive after the adaptee instance is not used anymore and can be safely collected. 

**Obs: This class is not singleton, but have an `GLOBAL` instance, and each `AdapterManager` has its own `Storage` instance, which is implemented by `WeakAdapteeStorage` and is visible to use.**

Example:
[DynamicFieldTest.java](https://github.com/JonathanxD/AdapterHelper/tree/master/src/test/java/com/github/jonathanxd/adapterhelper/test/DynamicFieldTest.java).

## Concrete Adapters

You are free to use concrete adapters and register them in `AdapterManager`, if you have only concrete adapters and does not use deep inheritance system, you don't need `CodeAPI`, `CodeAPI-BytecodeWriter`, `CodeProxy` nor `CodeGenUtil`.

## Adapter collections

Provides collections which handles and delegates adaptation to a wrapped instance, this means that if you adapt `OldPerson` to `Person` and them create a `List` of `Person` from a `List` of `OldPerson` (using `AdapterManager`), all changes made on both `List`s will be reflected on each other.

Currently, we only implemented `Collection`, `List`, `Set` and `Map`. You can also open an issue to request more implementations or send a pull request of implementation of other classes (and we will accept happily).  But we only accepts implementations on top of Java or Kotlin classes.

#### Important

Deep adaptation system is in beta stage, this means that bugs may (and probably will) happen, then is very important to you report them.